#+title: Fenwick Tree

#+STARTUP: showall indent
#+STARTUP: hidestars
#+TOC: nil  ;; Disable table of contents by default
#+OPTIONS: toc:nil  ;; Disable TOC in HTML export

#+BEGIN_EXPORT html
---
layout: default
title: Fenwick Tree
nav_exclude: true
---
#+END_EXPORT


* Description
A Fenwick Tree is a binary indexed tree that allows efficient:
+ do range queries from [0, m] like (sum, max, min) in O(log n)
+ do point updates in O(log n)

Space used is n, the same size as the input range array
Fenwick Tree is using the left most binary bit of node index to represent the range.
For example:
1 in bin is 0001, will keep the range from 1 to 1
3 in bin is 0011, will keep the range from 3 to 3
4 in bin is 0100, will keep the range from 4 to 1


[[https://youtu.be/uSFzHCZ4E-8][Youtube: Fenwick Tree (Binary Index Tree) Quick Tutorial and Source Code Explanation]]

The Fenwick tree use the left most bit a lot, the followings are some tricks
#+begin_src
i & -i will give the left most binary bit
i - (i & -i) will remove the left most binary bit
#+end_src

* code
template
#+begin_src cpp
vector<int> arr(n);
vector<int> tree(n+1) // tree node start at index 1 not 0

// Fenwick Tree: update (0 based), increase node n and populate the effect to root
void update(vector<int>& tree, int node, int incr) {
  node ++;

  //populate to the parents
  while(node < tree.size()) {
    tree[node] += incr;
    node += (node & -node);    // go to the parent by adding the left most binary bit
  }
  return;
}

// Fenwick Tree: query the range [0, i] (0 based) for the sum
int query(vector<int>& tree, int i) {
  int ans = 0;
  i ++;
  // loop through each segment
  while(i>0) {
    ans += tree[i];
    i -= (i & -i);
  }

  return ans;
}

// key idea, add the current node to it's immediate parent
void build(vector<int>& tree, vector<int>& arr){
  copy(arr.begin(), arr.end(), tree.begin()+1);

  for(int i=1; i<tree.size(); i++) {
    int p = i + (i & -i);       // get the immediate parent
    if(p < tree.size()) {
      tree[p] += tree[i];       // add to the parent
    }
  }

  return;
}
#+end_src
